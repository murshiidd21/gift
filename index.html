<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For You</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Lato:wght@300;400&display=swap"
        rel="stylesheet">
    <style>
        body {
            background-color: #fcfbf7;
            background-image: url('floral-bg.png');
            /* Ensure this file exists or fallback */
            background-size: 300px;
            background-repeat: repeat;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Playfair Display', serif;
            overflow: hidden;
            touch-action: none;
            /* Prevent scrolling */
            user-select: none;
            /* Prevent selection */
            -webkit-user-select: none;
        }

        #card {
            background: rgba(255, 255, 255, 0.9);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(93, 64, 55, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.5) inset;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            backdrop-filter: blur(8px);
            max-width: 90%;
            width: 340px;
            border: 1px solid rgba(212, 163, 115, 0.3);
        }

        h1 {
            font-size: 1.8rem;
            color: #5d4037;
            margin: 0 0 30px 0;
            font-weight: 400;
            letter-spacing: 0.5px;
            text-align: center;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        #crank-container {
            position: relative;
            width: 220px;
            height: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(230, 224, 212, 0.3) 0%, rgba(255, 255, 255, 0) 70%);
        }

        /* The Crank Image */
        #crank {
            width: 100%;
            height: 100%;
            background-image: url('crank.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: grab;
            filter: drop-shadow(4px 4px 8px rgba(93, 64, 55, 0.2));
            transform-origin: 50% 50%;
            will-change: transform;
            transition: transform 0.05s linear;
            mix-blend-mode: multiply;
            /* Handles white background in image */
        }

        #crank:active {
            cursor: grabbing;
            transform: scale(0.98);
            /* Press effect */
        }

        /* Progress Bar */
        #progress-container {
            width: 80%;
            height: 6px;
            background: #e6e0d4;
            border-radius: 3px;
            margin-top: 20px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #d4a373, #8d6e63);
            transition: width 0.1s linear;
        }

        #instruction {
            margin-top: 20px;
            color: #8d7b6f;
            font-family: 'Lato', sans-serif;
            font-size: 0.95rem;
            letter-spacing: 0.5px;
            opacity: 0.8;
            transition: opacity 0.5s;
            text-transform: uppercase;
            font-size: 0.75rem;
            font-weight: bold;
        }

        /* Decorative flourishes */
        .decoration {
            position: absolute;
            font-size: 2rem;
            color: #d4a373;
            opacity: 0.2;
            pointer-events: none;
            user-select: none;
        }

        .top-left {
            top: 10px;
            left: 10px;
            transform: rotate(-45deg);
        }

        .bottom-right {
            bottom: 10px;
            right: 10px;
            transform: rotate(135deg);
        }
    </style>
</head>

<body>

    <div id="card">
        <div class="decoration top-left">❀</div>
        <div class="decoration bottom-right">❀</div>

        <h1>For You</h1>

        <div id="crank-container">
            <div id="crank"></div>
        </div>

        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>

        <p id="instruction">Wind clockwise to listen</p>
    </div>

    <audio id="audioPlayer" src="voice.mp3" preload="auto" loop></audio>

    <script>
        const crank = document.getElementById('crank');
        const progressBar = document.getElementById('progress-bar');
        const instruction = document.getElementById('instruction');

        // Web Audio API Context
        // We use this because standard <audio> volume control doesn't work on iOS
        let audioCtx;
        let audioSource;
        let gainNode;
        let audioBuffer;
        let isAudioLoaded = false;
        let isAudioPlaying = false;
        let audioStartTime = 0;
        let audioOffset = 0;

        // Load Audio Buffer for responsive playback (better than streaming HTML5 audio for scrubbing/speed)
        async function initAudio() {
            if (isAudioLoaded) return;
            try {
                const response = await fetch('voice.mp3');
                const arrayBuffer = await response.arrayBuffer();
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                isAudioLoaded = true;
            } catch (error) {
                console.error("Audio init failed:", error);
            }
        }

        // Initialize on first interaction
        function enableAudio() {
            if (!audioCtx) initAudio();
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // Source Management
        let currentSourceNode = null;

        function updateAudioPlayback(speed) {
            if (!isAudioLoaded || !audioCtx) return;

            // Calculate gain (volume) based on speed
            // Smooth fade in/out
            const targetVolume = Math.min(1, Math.max(0, (speed - 0.5) * 2)); // 0.5 speed = 0 vol, 1.0 speed = 1 vol

            if (speed > 0.1) {
                if (!isAudioPlaying) {
                    playSource();
                }

                // Update Playback Rate
                if (currentSourceNode) {
                    const rate = Math.max(0.5, Math.min(speed / 10, 2.0)); // Normalize speed to rate
                    currentSourceNode.playbackRate.value = rate;
                }

                // Update Volume
                if (gainNode) {
                    gainNode.gain.setTargetAtTime(1, audioCtx.currentTime, 0.1); // Smooth ramp to full
                }

                instruction.style.opacity = 0;
            } else {
                // Stop/Fade out
                if (gainNode) {
                    gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                }
                // We don't stop the node immediately to allow smooth fade out
                // But if speed stays 0 for a while, we could pause? 
                // For now, let it run silent (looping) is easier for continuity.

                instruction.style.opacity = isDragging ? 0 : 1;
            }
        }

        function playSource() {
            if (isAudioPlaying || !audioBuffer) return;

            // Create graph
            currentSourceNode = audioCtx.createBufferSource();
            currentSourceNode.buffer = audioBuffer;
            currentSourceNode.loop = true;

            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0; // Start silent

            currentSourceNode.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            currentSourceNode.start(0, audioOffset);
            isAudioPlaying = true;
            lastPlayTime = audioCtx.currentTime;
        }

        // Physics State
        let isDragging = false;
        let lastAngle = 0;
        let currentRotation = 0;
        let lastRotation = 0;
        let velocity = 0;
        let crankCenter = { x: 0, y: 0 };

        // Optimized Center Caching
        function updateCenter() {
            const rect = crank.getBoundingClientRect();
            crankCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        // Initial Center Update
        updateCenter();
        window.addEventListener('resize', updateCenter);
        window.addEventListener('scroll', updateCenter);

        function getAngle(x, y) {
            // Use cached center to avoid thrashing
            return Math.atan2(y - crankCenter.y, x - crankCenter.x) * (180 / Math.PI);
        }

        function startDrag(e) {
            isDragging = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // Re-update center on touch start for safety (e.g. slight scroll shifts)
            updateCenter();

            lastAngle = getAngle(clientX, clientY);
            enableAudio();

            crank.style.transition = 'none'; // Instant response
        }

        function rotate(e) {
            if (!isDragging) return;
            e.preventDefault(); // Critical for mobile to prevent scroll

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // Deadzone check: if too close to center, angles go wild. Ignore.
            const dist = Math.hypot(clientX - crankCenter.x, clientY - crankCenter.y);
            if (dist < 20) return; // 20px deadzone

            const newAngle = getAngle(clientX, clientY);
            let delta = newAngle - lastAngle;

            // Unwrap Angle
            if (delta > 180) delta -= 360;
            if (delta < -180) delta += 360;

            currentRotation += delta;
            lastAngle = newAngle;
        }

        function stopDrag() {
            isDragging = false;
            // Add a little exit momentum transition
            crank.style.transition = 'transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        }

        // Loop
        function loop() {
            // Calculate Inertia/Momentum
            // We use 'velocity' to track speed. 
            // If dragging, velocity = current frame delta.
            // If released, velocity decays.

            let frameDelta = currentRotation - lastRotation;
            lastRotation = currentRotation;

            if (isDragging) {
                // Smooth out input jitter
                velocity += (frameDelta - velocity) * 0.3;
            } else {
                // Decay
                velocity *= 0.95;
                // Apply velocity to rotation when not dragging (spin effect)
                currentRotation += velocity;
            }

            // Apply Transform
            // Use translateZ(0) to force GPU layer
            crank.style.transform = `rotate(${currentRotation}deg) translateZ(0)`;

            // Audio Sync
            updateAudioPlayback(Math.abs(velocity));

            // Progress Bar simulation (just visual based on raw rotation for now, or tie to audio time if needed)
            // Since we are looping a buffer, "progress" is relative to the loop. 
            // Let's just create a nice visual effect that fills up as you wind.
            // Or use the actual audio time if we tracked it?
            // With BufferSource, we can't easily get 'currentTime' like <audio> element without tracking it manually.
            // Let's simluate progress based on total rotation bound.

            let progress = (Math.abs(currentRotation) % 3600) / 36; // 10 spins = 100%
            progressBar.style.width = `${progress}%`;

            requestAnimationFrame(loop);
        }

        // Event Listeners
        // Use passive: false to allow preventDefault
        crank.addEventListener('mousedown', startDrag);
        window.addEventListener('mousemove', rotate);
        window.addEventListener('mouseup', stopDrag);

        // Mobile: Attach to container or body to catch 'fat finger' misses
        const touchTarget = document.getElementById('card');
        // actually sticking to crank but ensuring hit area is handled by UI layout

        crank.addEventListener('touchstart', startDrag, { passive: false });
        window.addEventListener('touchmove', rotate, { passive: false });
        window.addEventListener('touchend', stopDrag);
        window.addEventListener('touchcancel', stopDrag);

        requestAnimationFrame(loop);

    </script>
</body>

</html>
